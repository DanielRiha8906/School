BIC(dlm3)
# zakresleni modelu do dat
arima1d <- ts.intersect(na.omit(xy2_series[,1]), arima1$fitted)
plot.ts(arima1d, plot.type = "single", col=c("orange","blue"),
lty=c(1,4), lwd=c(1,1),
main = "ARIMA errors model - Original (orange) and Fitted series (blue)")
# vyznamnost koeficientu ARIMA modelu
coeftest(arima1)
# najdete optimalni model pro radu co2
rada <- co2
# najdete optimalni model pro radu co2
rada <- co2
View(rada)
plot(rada)
find_best_arima <- function(data) {
# Define a list of ARIMA model specifications
arima_specs <- list(
list(name = "ARIMA(1,0,0)(0,1,0)", order = c(0, 0, 0), seasonal = list(order = c(0, 1, 0))),
list(name = "ARIMA(1,0,0)(0,1,0)", order = c(1, 0, 0), seasonal = list(order = c(0, 1, 0))),
list(name = "ARIMA(1,0,0)(0,1,0)", order = c(0, 0, 1), seasonal = list(order = c(0, 1, 0))),
list(name = "ARIMA(1,0,0)(0,1,0)", order = c(1, 0, 1), seasonal = list(order = c(0, 1, 0))),
list(name = "ARIMA(1,0,0)(0,1,0)", order = c(0, 0, 0), seasonal = list(order = c(1, 1, 0))),
list(name = "ARIMA(1,0,0)(0,1,0)", order = c(1, 0, 0), seasonal = list(order = c(1, 1, 0))),
list(name = "ARIMA(1,0,0)(0,1,0)", order = c(0, 0, 1), seasonal = list(order = c(1, 1, 0))),
list(name = "ARIMA(1,0,0)(0,1,0)", order = c(1, 0, 1), seasonal = list(order = c(1, 1, 0))),
list(name = "ARIMA(1,0,0)(0,1,0)", order = c(0, 0, 0), seasonal = list(order = c(0, 1, 1))),
list(name = "ARIMA(1,0,0)(0,1,0)", order = c(1, 0, 0), seasonal = list(order = c(0, 1, 1))),
list(name = "ARIMA(1,0,0)(0,1,0)", order = c(0, 0, 1), seasonal = list(order = c(0, 1, 1))),
list(name = "ARIMA(1,0,0)(0,1,0)", order = c(1, 0, 1), seasonal = list(order = c(0, 1, 1))),
list(name = "ARIMA(1,0,0)(0,1,0)", order = c(0, 0, 0), seasonal = list(order = c(1, 1, 1))),
list(name = "ARIMA(1,0,0)(0,1,0)", order = c(1, 0, 0), seasonal = list(order = c(1, 1, 1))),
list(name = "ARIMA(1,0,0)(0,1,0)", order = c(0, 0, 1), seasonal = list(order = c(1, 1, 1))),
list(name = "ARIMA(1,0,0)(0,1,0)", order = c(1, 0, 1), seasonal = list(order = c(1, 1, 1))),
list(name = "ARIMA(1,0,0)(0,0,0)", order = c(0, 0, 0), seasonal = list(order = c(0, 0, 0))),
list(name = "ARIMA(1,0,0)(0,0,0)", order = c(1, 0, 0), seasonal = list(order = c(0, 0, 0))),
list(name = "ARIMA(1,0,0)(0,0,0)", order = c(0, 0, 1), seasonal = list(order = c(0, 0, 0))),
list(name = "ARIMA(1,0,0)(0,0,0)", order = c(1, 0, 1), seasonal = list(order = c(0, 0, 0))),
list(name = "ARIMA(1,0,0)(0,0,0)", order = c(0, 0, 0), seasonal = list(order = c(1, 0, 0))),
list(name = "ARIMA(1,0,0)(0,0,0)", order = c(1, 0, 0), seasonal = list(order = c(1, 0, 0))),
list(name = "ARIMA(1,0,0)(0,0,0)", order = c(0, 0, 1), seasonal = list(order = c(1, 0, 0))),
list(name = "ARIMA(1,0,0)(0,0,0)", order = c(1, 0, 1), seasonal = list(order = c(1, 0, 0))),
list(name = "ARIMA(1,0,0)(0,0,0)", order = c(0, 0, 0), seasonal = list(order = c(0, 0, 1))),
list(name = "ARIMA(1,0,0)(0,0,0)", order = c(1, 0, 0), seasonal = list(order = c(0, 0, 1))),
list(name = "ARIMA(1,0,0)(0,0,0)", order = c(0, 0, 1), seasonal = list(order = c(0, 0, 1))),
list(name = "ARIMA(1,0,0)(0,0,0)", order = c(1, 0, 1), seasonal = list(order = c(0, 0, 1))),
list(name = "ARIMA(1,0,0)(0,0,0)", order = c(0, 0, 0), seasonal = list(order = c(1, 0, 1))),
list(name = "ARIMA(1,0,0)(0,0,0)", order = c(1, 0, 0), seasonal = list(order = c(1, 0, 1))),
list(name = "ARIMA(1,0,0)(0,0,0)", order = c(0, 0, 1), seasonal = list(order = c(1, 0, 1))),
list(name = "ARIMA(1,0,0)(0,0,0)", order = c(1, 0, 1), seasonal = list(order = c(1, 0, 1))),
list(name = "ARIMA(1,1,0)(0,1,0)", order = c(0, 1, 0), seasonal = list(order = c(0, 1, 0))),
list(name = "ARIMA(1,1,0)(0,1,0)", order = c(1, 1, 0), seasonal = list(order = c(0, 1, 0))),
list(name = "ARIMA(1,1,0)(0,1,0)", order = c(0, 1, 1), seasonal = list(order = c(0, 1, 0))),
list(name = "ARIMA(1,1,0)(0,1,0)", order = c(1, 1, 1), seasonal = list(order = c(0, 1, 0))),
list(name = "ARIMA(1,1,0)(0,1,0)", order = c(0, 1, 0), seasonal = list(order = c(1, 1, 0))),
list(name = "ARIMA(1,1,0)(0,1,0)", order = c(1, 1, 0), seasonal = list(order = c(1, 1, 0))),
list(name = "ARIMA(1,1,0)(0,1,0)", order = c(0, 1, 1), seasonal = list(order = c(1, 1, 0))),
list(name = "ARIMA(1,1,0)(0,1,0)", order = c(1, 1, 1), seasonal = list(order = c(1, 1, 0))),
list(name = "ARIMA(1,1,0)(0,1,0)", order = c(0, 1, 0), seasonal = list(order = c(0, 1, 1))),
list(name = "ARIMA(1,1,0)(0,1,0)", order = c(1, 1, 0), seasonal = list(order = c(0, 1, 1))),
list(name = "ARIMA(1,1,0)(0,1,0)", order = c(0, 1, 1), seasonal = list(order = c(0, 1, 1))),
list(name = "ARIMA(1,1,0)(0,1,0)", order = c(1, 1, 1), seasonal = list(order = c(0, 1, 1))),
list(name = "ARIMA(1,1,0)(0,1,0)", order = c(0, 1, 0), seasonal = list(order = c(1, 1, 1))),
list(name = "ARIMA(1,1,0)(0,1,0)", order = c(1, 1, 0), seasonal = list(order = c(1, 1, 1))),
list(name = "ARIMA(1,1,0)(0,1,0)", order = c(0, 1, 1), seasonal = list(order = c(1, 1, 1))),
list(name = "ARIMA(1,1,0)(0,1,0)", order = c(1, 1, 1), seasonal = list(order = c(1, 1, 1))),
list(name = "ARIMA(1,1,0)(0,0,0)", order = c(0, 1, 0), seasonal = list(order = c(0, 0, 0))),
list(name = "ARIMA(1,1,0)(0,0,0)", order = c(1, 1, 0), seasonal = list(order = c(0, 0, 0))),
list(name = "ARIMA(1,1,0)(0,0,0)", order = c(0, 1, 1), seasonal = list(order = c(0, 0, 0))),
list(name = "ARIMA(1,1,0)(0,0,0)", order = c(1, 1, 1), seasonal = list(order = c(0, 0, 0))),
list(name = "ARIMA(1,1,0)(0,0,0)", order = c(0, 1, 0), seasonal = list(order = c(1, 0, 0))),
list(name = "ARIMA(1,1,0)(0,0,0)", order = c(1, 1, 0), seasonal = list(order = c(1, 0, 0))),
list(name = "ARIMA(1,1,0)(0,0,0)", order = c(0, 1, 1), seasonal = list(order = c(1, 0, 0))),
list(name = "ARIMA(1,1,0)(0,0,0)", order = c(1, 1, 1), seasonal = list(order = c(1, 0, 0))),
list(name = "ARIMA(1,1,0)(0,0,0)", order = c(0, 1, 0), seasonal = list(order = c(0, 0, 1))),
list(name = "ARIMA(1,1,0)(0,0,0)", order = c(1, 1, 0), seasonal = list(order = c(0, 0, 1))),
list(name = "ARIMA(1,1,0)(0,0,0)", order = c(0, 1, 1), seasonal = list(order = c(0, 0, 1))),
list(name = "ARIMA(1,1,0)(0,0,0)", order = c(1, 1, 1), seasonal = list(order = c(0, 0, 1))),
list(name = "ARIMA(1,1,0)(0,0,0)", order = c(0, 1, 0), seasonal = list(order = c(1, 0, 1))),
list(name = "ARIMA(1,1,0)(0,0,0)", order = c(1, 1, 0), seasonal = list(order = c(1, 0, 1))),
list(name = "ARIMA(1,1,0)(0,0,0)", order = c(0, 1, 1), seasonal = list(order = c(1, 0, 1))),
list(name = "ARIMA(1,1,0)(0,0,0)", order = c(1, 1, 1), seasonal = list(order = c(1, 0, 1)))
)
# Initialize variables to track best model and minimum BIC
best_model <- NULL
best_spec <- NULL
best_bic <- Inf
# Iterate over each ARIMA model specification
for (i in seq_along(arima_specs)) {
spec <- arima_specs[[i]]
# Fit the ARIMA model
fit <- tryCatch(
arima(data, order = spec$order, seasonal = spec$seasonal),
error = function(e) NULL  # Handle errors gracefully
)
# Calculate BIC and update best model if BIC is lower
if (!is.null(fit)) {
bic <- BIC(fit)
if (bic < best_bic) {
best_bic <- bic
best_model <- fit
best_spec <- spec$name  # Track the winning model specification
}
}
}
# Return the best model, selected ARIMA model specification, and BIC value
return(list(best_model = best_model, best_spec = best_spec, best_bic = best_bic))
}
result <- find_best_arima(rada)
print(result$best_spec)
print(result$best_model)
print(result$best_bic)
result <- find_best_arima(rada)
print(result$best_spec)
print(result$best_model)
print(result$best_bic)
model <- arima(your_data, order = c(1, 1, 0), seasonal = c(0, 1, 0))
summary(model)
model <- arima(rada, order = c(1, 1, 0), seasonal = c(0, 1, 0))
summary(model)
library(devtools)
install.packages('usethis')
for.model <- forecast(model)
library(forecast)
for.model <- forecast(model)
View(for.model)
plot(for.model)
# Aditivní, ne multiplikativní
# hledejte optimalni model pro radu ozonu v datech airquality v zavislosti na ostatnich promennych
data <- airquality
ccf(ts(airquality$Ozone),ts(airquality$Solar.R),na.action = na.pass)
View(airquality)
ccf(ts(airquality$Ozone),ts(airquality$Wind),na.action = na.pass)
ccf(ts(airquality$Ozone),ts(airquality$Temp),na.action = na.pass)
ccf(ts(airquality$Ozone),ts(airquality$Solar.R),na.action = na.pass)
ccf(ts(airquality$Ozone),ts(airquality$Wind),na.action = na.pass)
ccf(ts(airquality$Ozone),ts(airquality$Temp),na.action = na.pass)
result <- find_best_arima(rada)
print(result$best_spec)
print(result$best_model)
print(result$best_bic)
ccf(ts(airquality$Ozone),ts(airquality$Solar.R),na.action = na.pass)
ccf(ts(airquality$Ozone),ts(airquality$Wind),na.action = na.pass)
ccf(ts(airquality$Ozone),ts(airquality$Temp),na.action = na.pass)
arima <- find_best_arima(airquality)
print(result$best_spec)
arima <- auto.arima(airquality)
ts_data <- ts(airquality[, c("Ozone", "Temp")], frequency = 30)
arima <- auto.arima(ts_data)
############################
### prozkoumejme vzajemne vztahy mezi radami souboru airquality
# kroskorelacni funkce
ccf(ts(airquality$Wind),ts(airquality$Solar.R),na.action = na.pass)
# nejsou zavisle
ccf(ts(airquality$Wind),ts(airquality$Ozone),na.action = na.pass)
# generovani dat
set.seed(999)
x_series <- arima.sim(n = 200, list(order = c(1,0,0), ar = 0.7, sd=1))
# nasimulovany AR(1) proces
z <- ts.intersect(stats::lag(x_series, -1), stats::lag(x_series, -2))
# hodnoty rady x_series v case t a t-1
y_series <- 15 + 0.8*z[,1] + 1.5*z[,2] + rnorm(199,0,1)
# kombinace aktualni a zpozdene hodnoty + nahodne chyby
xy_series <- ts.intersect(y_series, z)
# model pomoci bezne linearni regrese
lm1 <- lm(xy_series[,1] ~ xy_series[,2] + xy_series[,3])
summary(lm1)
checkresiduals(lm1)
# model pomoci dynamickeho modelovani
dlm1 <- dynlm(y_series ~ L(x_series, 1) + L(x_series, 2))
library(dynlm)
############################
library(forecast)
library(dynlm)
library(lmtest)
# model pomoci dynamickeho modelovani
dlm1 <- dynlm(y_series ~ L(x_series, 1) + L(x_series, 2))
summary(dlm1)
### pouziti dynamickeho modelovani k odhaleni trendu a sezonnosti
plot(AirPassengers)
# multiplikativni rada, udelam z ni logaritmus
ap <- log(AirPassengers)
plot(ap)
# pridam zavislost na tretim pozorovani dozadu
set.seed(123)
ap_x <- 2 * stats::lag(ap, -3) + rnorm(length(ap), 0, 0.2)
# dynamicky linearni model
dlm2 <- dynlm(ap ~ trend(ap) + season(ap) + L(ap_x, 3))
summary(dlm2)
dlm2.o <- ts.intersect(ap, dlm2$fitted.values)
plot.ts(dlm2.o, plot.type = "single", col=c("orange","blue"),
lty=c(1,4), lwd=c(1,1),
main = "Dynamic Linear Model - Original (orange) and Fitted series (blue)")
dynlm(co2~trend(co2) + season(CO2))
dynlm(CO2~trend(CO2) + season(CO2))
co <- dynlm(CO2~trend(CO2) + season(CO2))
co <- dynlm(co2~trend(co2) + season(co2))
co
############################
library(forecast)
library(dynlm)
library(lmtest)
############################
data("M1Germany")
head(M1Germany)
plot(M1Germany$logm1)
# autokorelacni funkce
par(mfrow=c(2,1))
acf(M1Germany$logm1,na.action =na.pass)
pacf(M1Germany$logm1,na.action =na.pass)
par(mfrow=c(1,1))
# zavislost na ostatnich raddach
par(mfrow=c(3,1))
ccf(M1Germany$logm1,M1Germany$logprice,na.action =na.pass)
ccf(M1Germany$logm1,M1Germany$loggnp,na.action =na.pass)
ccf(M1Germany$logm1,M1Germany$interest,na.action =na.pass)
par(mfrow=c(1,1))
# nejprve se podivame na radu jako takovou
plot(decompose(M1Germany$logm1))
m1<-dynlm(M1Germany$logm1~trend(M1Germany$logm1)+season(M1Germany$logm1))
summary(m1)
# odhady koeficientu trendu i sezonni slozky
acf(m1$residuals)
# potrebuji matici "vysvetlujicich promennych tohoto modelu
m1$model[1:20,]
zavisla<-m1$model[,1]
# namisto puvodni rady logm1 pouzivam tu z modelu, kde jsou vynechana chybejici pozorovani
x.reg1<-m1$model[,2:3]
# regresory
x.reg2<-cbind("trend"=x.reg1[,1],"Q2"=ifelse(x.reg1[,2]=="Q2",1,0),
"Q3"=ifelse(x.reg1[,2]=="Q3",1,0),"Q4"=ifelse(x.reg1[,2]=="Q4",1,0))
head(x.reg2)
# vytvoreni "dummy variables" do modelu
x.reg3<-as.matrix(x.reg2)
# auto.arima potrebuje regresory ve tvaru matice
m2<-auto.arima(zavisla,xreg=x.reg3)
summary(m2)
# vysledny model
acf(m2$residuals)
# vysledny model
acf(m2$residuals)
# mam nekorelovana residua - dobry model
checkresiduals(m2)
# zavislost na ostatnich promennych
m3<-dynlm(M1Germany$logm1~M1Germany$logprice+M1Germany$loggnp+M1Germany$interest)
# zavislost v aktualnim case
summary(m3)
# shrnuti modelu
# ale neni lepsi brat i promenne interest zavislost se zpozdenim?
m4<-dynlm(M1Germany$logm1~M1Germany$logprice+M1Germany$loggnp+L(M1Germany$interest,-4))
# zpozdeni o 4 kroky
summary(m4)
acf(m3$residuals)
m5<-auto.arima(M1Germany$logm1,xreg=x.reg)
summary(m5)
m5<-auto.arima(M1Germany$logm1,xreg=x.reg)
# mam korelovana residua, musim pridat jeste cast arima
# vytvoreni matice regresoru
x.reg<-as.matrix(M1Germany[,2:4])
m5<-auto.arima(M1Germany$logm1,xreg=x.reg)
summary(m5)
coeftest(m5)
# vsechny koeficienty modelu jsou vyznamne
acf(m5$residuals,na.action = na.pass)
# vsechny koeficienty modelu jsou vyznamne
acf(m5$residuals,na.action = na.pass)
# nekorelovana residua - dobry model
checkresiduals(m5)
# auto arima
m6<-auto.arima(M1Germany$logm1)
summary(m6)
acf(m6$residuals,na.action = na.pass)
# ktery model je nejlepsi?
BIC(m1)
BIC(m2)
BIC(m3)
BIC(m5)
BIC(m6)
############################
library(forecast)
library(dynlm)
library(lmtest)
# nacteni knihoven
############################
data("M1Germany")
head(M1Germany)
# ekonomicka ctvrtletni data z Nemecka
# M1 index "financni zasoby"
plot(M1Germany$logm1)
# casova rada s trendem a sezonnosti, jak pro ni najit optimalni model?
# autokorelacni funkce
par(mfrow=c(2,1))
acf(M1Germany$logm1,na.action =na.pass)
pacf(M1Germany$logm1,na.action =na.pass)
par(mfrow=c(1,1))
# je videt vysoka autokorelovanost (diky trendu)
# zavislost na ostatnich raddach
par(mfrow=c(3,1))
ccf(M1Germany$logm1,M1Germany$logprice,na.action =na.pass)
ccf(M1Germany$logm1,M1Germany$loggnp,na.action =na.pass)
ccf(M1Germany$logm1,M1Germany$interest,na.action =na.pass)
par(mfrow=c(1,1))
# je videt vysoka korelovanost s ostatnimi radami
# s logprice a loggnp s nulovym zpozdenim
# s interest se zpozdenim 4 roky
# nejprve se podivame na radu jako takovou
plot(decompose(M1Germany$logm1))
m1<-dynlm(M1Germany$logm1~trend(M1Germany$logm1)+season(M1Germany$logm1))
summary(m1)
# odhady koeficientu trendu i sezonni slozky
acf(m1$residuals)
# residua jsou korelovana, je treba pridat arima model pro ne
# potrebuji matici "vysvetlujicich promennych tohoto modelu
m1$model[1:20,]
zavisla<-m1$model[,1]
# namisto puvodni rady logm1 pouzivam tu z modelu, kde jsou vynechana chybejici pozorovani
x.reg1<-m1$model[,2:3]
# regresory
x.reg2<-cbind("trend"=x.reg1[,1],"Q2"=ifelse(x.reg1[,2]=="Q2",1,0),
"Q3"=ifelse(x.reg1[,2]=="Q3",1,0),"Q4"=ifelse(x.reg1[,2]=="Q4",1,0))
head(x.reg2)
# vytvoreni "dummy variables" do modelu
x.reg3<-as.matrix(x.reg2)
# auto.arima potrebuje regresory ve tvaru matice
m2<-auto.arima(zavisla,xreg=x.reg3)
summary(m2)
# vysledny model
acf(m2$residuals)
# mam nekorelovana residua - dobry model
checkresiduals(m2)
# zavislost na ostatnich promennych
m3<-dynlm(M1Germany$logm1~M1Germany$logprice+M1Germany$loggnp+M1Germany$interest)
# zavislost v aktualnim case
summary(m3)
# shrnuti modelu
# ale neni lepsi brat i promenne interest zavislost se zpozdenim?
m4<-dynlm(M1Germany$logm1~M1Germany$logprice+M1Germany$loggnp+L(M1Germany$interest,-4))
# zpozdeni o 4 kroky
summary(m4)
# nevypada to
acf(m3$residuals)
# mam korelovana residua, musim pridat jeste cast arima
# vytvoreni matice regresoru
x.reg<-as.matrix(M1Germany[,2:4])
m5<-auto.arima(M1Germany$logm1,xreg=x.reg)
summary(m5)
coeftest(m5)
# vsechny koeficienty modelu jsou vyznamne
acf(m5$residuals,na.action = na.pass)
# nekorelovana residua - dobry model
checkresiduals(m5)
# auto arima
m6<-auto.arima(M1Germany$logm1)
summary(m6)
acf(m6$residuals,na.action = na.pass)
# nekorelovana residua - dobry model
# ktery model je nejlepsi?
BIC(m1)
BIC(m2)
BIC(m3)
BIC(m5)
BIC(m6)
plot(M1Germany$logm1)
lines(m2$fitted,col=2)
plot(M1Germany$logm1)
lines(m5$fitted,col=3)
plot(M1Germany$logm1)
lines(m2$fitted,col=2)
# predpovedi
# mohu pocitat jen pro model m2, pro model m5 nemam hodnoty regresoru
newd1<-data.frame("trend"=seq(36.25,38,by=0.25),"Q2"=c(0,1,0,0,0,1,0,0),
"Q3"=c(0,0,1,0,0,0,1,0),"Q4"=c(0,0,0,1,0,0,0,1))
newd2<-as.matrix(newd1)
f2<-forecast(m2,xreg=newd2)
plot(f2)
f2
# pouzijte databazi EuStockMarkets a zkuste najit optimalni model pro index DAX
# databaze burzovnich indexu
plot(EuStockMarkets[,1])
# pouzijte databazi EuStockMarkets a zkuste najit optimalni model pro index DAX
# databaze burzovnich indexu
a <- EuStockMarkets[,1]
plot(a)
par(mfrow=c(2,1))
acf(a$DAX,na.action =na.pass)
View(a)
plot(a)
# pouzijte databazi EuStockMarkets a zkuste najit optimalni model pro index DAX
# databaze burzovnich indexu
a<- ts(EuStockMarkets[,1])
plot(EuStockMarkets[,1])
par(mfrow=c(2,1))
par(mfrow=c(2,1))
acf(a$DAX,na.action =na.pass)
# pouzijte databazi EuStockMarkets a zkuste najit optimalni model pro index DAX
# databaze burzovnich indexu
head(EuStockMarkets)
DAX <- EuStockMarkets[,1]
SMI <- EuStockMarkets[,1]
CAC <- EuStockMarkets[,1]
FTSE<- EuStockMarkets[,1]
mESM<- dynlm(DAX~SMI)
summary(mESM)
DAX <- EuStockMarkets[,1]
SMI <- EuStockMarkets[,2]
CAC <- EuStockMarkets[,3]
FTSE<- EuStockMarkets[,4]
mESM<- dynlm(DAX~SMI)
summary(mESM)
par(mfrow=c(2,1))
acf(EuStockMarkets[,1],na.action =na.pass)
pacf(EuStockMakrets[,1],na.action =na.pass)
par(mfrow=c(1,1))
pacf(EuStockMarkets[,1],na.action =na.pass)
par(mfrow=c(1,1))
acf(EuStockMarkets[,1],na.action =na.pass)
par(mfrow=c(3,1))
ccf(EuStockMarkets[,1],EuStockMarkets[,2],na.action =na.pass)
ccf(EuStockMarkets[,1],EuStockMarkets[,3],na.action =na.pass)
ccf(EuStockMarkets[,1],EuStockMarkets[,4],na.action =na.pass)
par(mfrow=c(1,1))
plot(decompose(EuStockMarkets[,1]))
m1<-dynlm(EuStockMarkets[,1]~trend(EuStockMarkets[,1])+season(EuStockMarkets[,1])
summary(m1)
m1 <- dynlm(EuStockMarkets[,1] ~ trend(EuStockMarkets[,1]) + season(EuStockMarkets[,1]))
summary(m1)
acf(m1$residuals)
m3<-dynlm(EuStockMarkets[,1]~EuStockMarkets[,2]+EuStockMarkets[,3]+EuStockMarkets[,4])
plot(m3)
checkresiduals(m3$residuals)
xreg <- as.matrix(EuStockMarkets[,2:4])
autoarima(EuStockMarkets[,1], x.reg=xreg)
auto.arima(EuStockMarkets[,1], x.reg=xreg)
model <- auto.arima(EuStockMarkets[,1], xreg = xreg, seasonal = FALSE)
checkresiduals(model$residuals)
model_2 <- arima(EuStockMarkets[,1], order=c(1,0,0), xreg = xreg)
checkresiduals(model$residuals)
par(mfrow=c(2,1))
checkresiduals(model$residuals)
checkresiduals(model2$residuals)
par(mfrow=c(6,1))
checkresiduals(model$residuals)
checkresiduals(mode2$residuals)
model_2 <- arima(EuStockMarkets[,1], order=c(1,0,0), xreg = xreg)
checkresiduals(model_2$residuals)
plot(EuStockMarkets[,1])
lines(model$fitted,col=2)
lines(model_2$fitted,col=3)
par(mfrow=c(1,1))
plot(EuStockMarkets[,1])
lines(model$fitted,col=2)
lines(model_2$fitted,col=3)
plot(EuStockMarkets[,1])
lines(model_2$fitted,col=3)
lines(model_2$fitted,col='green')
plot(EuStockMarkets[,1])
lines(model_2$fitted,col='green')
lines(model$fitted,col=2)
plot(EuStockMarkets[,1])
lines(model_2$fitted,col='green', lwd=4)
model_2 <- arima(EuStockMarkets[,1], order=c(1,0,0), xreg = xreg)
plot(EuStockMarkets[,1])
lines(model_2$fitted,col='green', lwd=4)
plot(model_2$fitted,col='green', lwd=4)
plot(model_2,col='green', lwd=4)
plot(model_2$fitted,col='green', lwd=4)
model_2 <- arima(EuStockMarkets[,1], order=c(1,0,0), xreg = xreg)
# Extract the fitted values from model_2
fitted_values <- fitted(model_2)
# Plot the original time series data
plot(EuStockMarkets[,1], type = 'l', col = 'black', lwd = 1, main = 'Original Data')
# Add the fitted values from model_2 to the plot
lines(index(EuStockMarkets[,1]), fitted_values, col = 'green', lwd = 2, lty = 1,
main = 'Original Data with Fitted Values')
# Add a legend for clarity
legend('topleft', legend = c('Original Data', 'Fitted Values (ARIMA)'),
col = c('black', 'green'), lty = c(1, 1), lwd = c(1, 2))
# Add the fitted values from model_2 to the plot
lines(index(EuStockMarkets[,1]), fitted_values, col = 'green', lwd = 1, lty = 1,
main = 'Original Data with Fitted Values')
# Plot the original time series data
plot(EuStockMarkets[,1], type = 'l', col = 'black', lwd = 1, main = 'Original Data')
# Add the fitted values from model_2 to the plot
lines(index(EuStockMarkets[,1]), fitted_values, col = 'green', lwd = 1, lty = 1,
main = 'Original Data with Fitted Values')
# Add the fitted values from model_2 to the plot
lines(index(EuStockMarkets[,1]), fitted_values, col = 'green', lwd = 100, lty = 1,
main = 'Original Data with Fitted Values')
# Add the fitted values from model_2 to the plot
lines(index(EuStockMarkets[,1]), fitted_values, col = 'green', lwd = 1000, lty = 1,
main = 'Original Data with Fitted Values')
# Add the fitted values from model_2 to the plot
lines(index(EuStockMarkets[,1]), fitted_values, col = 'green', lwd = 1, lty = 1,
main = 'Original Data with Fitted Values')
# Plot the original time series data
plot(EuStockMarkets[,1], type = 'l', col = 'black', lwd = 1, main = 'Original Data')
# Add the fitted values from model_2 to the plot
lines(index(EuStockMarkets[,1]), fitted_values, col = 'green', lwd = 1, lty = 1,
main = 'Original Data with Fitted Values')
# Add a legend for clarity
legend('topleft', legend = c('Original Data', 'Fitted Values (ARIMA)'),
col = c('black', 'green'), lty = c(1, 1), lwd = c(1, 2))
# sezonnost si vyzkousejte na rade
plot(UKgas)
load("~/Documents/Dan/Škola_Dan/School/Skola_kody/4_Semestr/CAS/EMG.RData")
# nactete data EMG a hledejte optimalni model pro radu iEMG
plot(EMG)
ts(EMG)
plot(ts(EMG))
EMG[,1]
EMG[,2]
EMG <- EMG[,2:4]
plot(ts(EMG))
